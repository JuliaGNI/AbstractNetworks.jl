var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AbstractNetworks","category":"page"},{"location":"#AbstractNetworks","page":"Home","title":"AbstractNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AbstractNetworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AbstractNetworks]","category":"page"},{"location":"#AbstractNetworks.AbstractExplicitLayer","page":"Home","title":"AbstractNetworks.AbstractExplicitLayer","text":"AbstractExplicitLayer\n\nAbstract supertype for explicit layers. This type exists mainly for compatibility with Lux.\n\n\n\n\n\n","category":"type"},{"location":"#AbstractNetworks.AbstractLayer","page":"Home","title":"AbstractNetworks.AbstractLayer","text":"AbstractLayer\n\nAn AbstractLayer is a map from mathbbR^M rightarrow mathbbR^N.\n\nConcrete layer types should implement the following functions:\n\ninitialparameters(backend::Backend, ::Type{T}, layer::AbstractLayer; init::Initializer = default_initializer(), rng::AbstractRNG = Random.default_rng())\nupdate!(::AbstractLayer, θ::NamedTuple, dθ::NamedTuple, η::AbstractFloat)\n\nand the functors\n\nlayer(x, ps)\nlayer(y, x, ps)\n\n\n\n\n\n","category":"type"},{"location":"#AbstractNetworks.Chain","page":"Home","title":"AbstractNetworks.Chain","text":"Chain\n\nA chain is a sequence of layers.\n\nA Chain can be initialized by passing an arbitrary number of layers\n\nChain(layers...)\n\nor a neural network architecture together with a backend and a parameter type:\n\nChain(::Architecture, ::Backend, ::Type; kwargs...)\nChain(::Architecture, ::Type; kwargs...)\n\nIf the backend is omitted, the default backend CPU() is chosen. The keyword arguments will be passed to the initialparameters method of each layer.\n\n\n\n\n\n","category":"type"},{"location":"#AbstractNetworks.apply!-Tuple{AbstractArray, AbstractNetworks.AbstractLayer, Any, Any}","page":"Home","title":"AbstractNetworks.apply!","text":"apply!(y, layer::AbstractLayer, x, ps)\n\nSimply calls layer(y, x, ps)\n\n\n\n\n\n","category":"method"},{"location":"#AbstractNetworks.apply-Tuple{AbstractNetworks.AbstractLayer, Any, Any}","page":"Home","title":"AbstractNetworks.apply","text":"apply(layer::AbstractLayer, x, ps)\n\nSimply calls layer(x, ps)\n\n\n\n\n\n","category":"method"},{"location":"#AbstractNetworks.initialparameters","page":"Home","title":"AbstractNetworks.initialparameters","text":"initialparameters\n\nReturns the initial parameters of a model, i.e., a layer or chain.\n\ninitialparameters(backend::Backend, ::Type{T}, model::Model; init::Initializer = default_initializer(), rng::AbstractRNG = Random.default_rng())\ninitialparameters(::Type{T}, model::Model; init::Initializer = default_initializer(), rng::AbstractRNG = Random.default_rng())\n\nThe init! function must have the following signature:\n\ninit!(rng::AbstractRNG, x::AbstractArray)\n\nThe default_initializer() returns randn!.\n\n\n\n\n\n","category":"function"}]
}
